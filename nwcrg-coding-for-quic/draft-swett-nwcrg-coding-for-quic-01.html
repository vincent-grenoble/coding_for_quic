<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Coding for QUIC</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Definitions and Abbreviations"/>
<link href="#rfc.section.3" rel="Chapter" title="3 General Design Considerations"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 FEC Code versus FEC Scheme, Block Codes versus Sliding Window Codes"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 FEC Scheme Negotiation"/>
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 FEC Protection Within an Encrypted Channel"/>
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 About Middleboxes"/>
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 FEC Protection at the Stream Level"/>
<link href="#rfc.section.3.6" rel="Chapter" title="3.6 About Gaps in the Set of Source Symbols Considered During Encoding"/>
<link href="#rfc.section.4" rel="Chapter" title="4 FEC Scheme Negotiation in QUIC"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Procedures when Protecting a Single QUIC Stream"/>
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Application data, STREAM Frame data and Source Symbols"/>
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Signaling Considerations within STREAM and REPAIR Frames"/>
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Management of Silent Periods and End of Stream"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Procedures when Protecting Several QUIC Streams"/>
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Application data, STREAM Frame data and Source Symbols"/>
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Block or Encoding Window Management"/>
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Signaling Considerations within STREAM and REPAIR Frames"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Security Considerations"/>
<link href="#rfc.section.8" rel="Chapter" title="8 IANA Considerations"/>
<link href="#rfc.section.9" rel="Chapter" title="9 Acknowledgments"/>
<link href="#rfc.references" rel="Chapter" title="10 References"/>
<link href="#rfc.references.1" rel="Chapter" title="10.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="10.2 Informative References"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.4.8 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Swett, I., Montpetit, M-J., and V. Roca" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-swett-nwcrg-coding-for-quic-01" />
  <meta name="dct.issued" scheme="ISO8601" content="2018-5-31" />
  <meta name="dct.abstract" content="This document focusses on the integration of FEC coding in the QUIC transport protocol, in order to recover from packet losses.  This document does not specify any FEC code but defines mechanisms to negotiate and integrate FEC Schemes in QUIC.  By using proactive loss recovery, it is expected to improve QUIC performance in sessions impacted by packet losses.  More precisely it is expected to improve QUIC performance with real-time sessions (since FEC coding makes packet loss recovery insensitive to the round trip time), with multicast sessions (since the same repair packet can recover several different losses at several receivers), and with multipath sessions (since repair packets add diversity).  " />
  <meta name="description" content="This document focusses on the integration of FEC coding in the QUIC transport protocol, in order to recover from packet losses.  This document does not specify any FEC code but defines mechanisms to negotiate and integrate FEC Schemes in QUIC.  By using proactive loss recovery, it is expected to improve QUIC performance in sessions impacted by packet losses.  More precisely it is expected to improve QUIC performance with real-time sessions (since FEC coding makes packet loss recovery insensitive to the round trip time), with multicast sessions (since the same repair packet can recover several different losses at several receivers), and with multipath sessions (since repair packets add diversity).  " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">nwcrg</td>
  <td class="right">I. Swett</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">Google</td>
</tr>
<tr>
  <td class="left">Intended status: Informational</td>
  <td class="right">M-J. Montpetit</td>
</tr>
<tr>
  <td class="left">Expires: December 2, 2018</td>
  <td class="right">Triangle Video</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">V. Roca</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">INRIA</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">May 31, 2018</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Coding for QUIC<br />
  <span class="filename">draft-swett-nwcrg-coding-for-quic-01</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document focusses on the integration of FEC coding in the QUIC transport protocol, in order to recover from packet losses.  This document does not specify any FEC code but defines mechanisms to negotiate and integrate FEC Schemes in QUIC.  By using proactive loss recovery, it is expected to improve QUIC performance in sessions impacted by packet losses.  More precisely it is expected to improve QUIC performance with real-time sessions (since FEC coding makes packet loss recovery insensitive to the round trip time), with multicast sessions (since the same repair packet can recover several different losses at several receivers), and with multipath sessions (since repair packets add diversity).  </p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on December 2, 2018.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2018 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>2.   <a href="#rfc.section.2">Definitions and Abbreviations</a></li>
<li>3.   <a href="#rfc.section.3">General Design Considerations</a></li>
<li>3.1.   <a href="#rfc.section.3.1">FEC Code versus FEC Scheme, Block Codes versus Sliding Window Codes</a></li>
<li>3.2.   <a href="#rfc.section.3.2">FEC Scheme Negotiation</a></li>
<li>3.3.   <a href="#rfc.section.3.3">FEC Protection Within an Encrypted Channel</a></li>
<li>3.4.   <a href="#rfc.section.3.4">About Middleboxes</a></li>
<li>3.5.   <a href="#rfc.section.3.5">FEC Protection at the Stream Level</a></li>
<li>3.6.   <a href="#rfc.section.3.6">About Gaps in the Set of Source Symbols Considered During Encoding</a></li>
<li>4.   <a href="#rfc.section.4">FEC Scheme Negotiation in QUIC</a></li>
<li>5.   <a href="#rfc.section.5">Procedures when Protecting a Single QUIC Stream</a></li>
<li>5.1.   <a href="#rfc.section.5.1">Application data, STREAM Frame data and Source Symbols</a></li>
<li>5.2.   <a href="#rfc.section.5.2">Signaling Considerations within STREAM and REPAIR Frames</a></li>
<li>5.3.   <a href="#rfc.section.5.3">Management of Silent Periods and End of Stream</a></li>
<li>6.   <a href="#rfc.section.6">Procedures when Protecting Several QUIC Streams</a></li>
<li>6.1.   <a href="#rfc.section.6.1">Application data, STREAM Frame data and Source Symbols</a></li>
<li>6.2.   <a href="#rfc.section.6.2">Block or Encoding Window Management</a></li>
<li>6.3.   <a href="#rfc.section.6.3">Signaling Considerations within STREAM and REPAIR Frames</a></li>
<li>7.   <a href="#rfc.section.7">Security Considerations</a></li>
<li>8.   <a href="#rfc.section.8">IANA Considerations</a></li>
<li>9.   <a href="#rfc.section.9">Acknowledgments</a></li>
<li>10.   <a href="#rfc.references">References</a></li>
<li>10.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>10.2.   <a href="#rfc.references.2">Informative References</a></li>
<li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">QUIC is a new transport that aims at improving network performance by enabling out of order delivery, partial reliability, and methods of recovery besides retransmission, while also improving security.  This document specifies a framework to enable FEC codes to be used to recover from lost packets within a single QUIC stream or across several QUIC streams.  </p>
<p id="rfc.section.1.p.2">The ability to add FEC coding in QUIC may be beneficial in several situations: </p>

<ul>
  <li>for a robust transmission of latency sensitive traffic, for instance real-time flows, since it enables to recover packet losses independently of the round trip time;</li>
  <li>for the transmission of contents to a large set of QUIC reception endpoints, since the same repair frame may help recovering several different packet losses at different receivers;</li>
  <li>for multipath communications, since repair traffic adds diversity.</li>
</ul>

<p> </p>
<p id="rfc.section.1.p.3">This framework does not mandate the use of any specific FEC code (i.e., how to encode and decode) nor FEC Scheme (i.e., that specifies both a FEC code and how to use it, in particular in terms of signaling).  Instead it allows to negotiate the FEC Scheme to use at session startup, assuming that more than one solution could potentially be offered concurrently.  Without loss of generality, we assume that the encoding operations compute a linear combination of QUIC packets, regardless of whether these codes are of block type (as with Reed-Solomon codes <a href="#RFC5510">[RFC5510]</a>) or sliding window type (as with RLC codes <a href="#RLC">[RLC]</a>).  </p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#definitionsAndAbbreviations" id="definitionsAndAbbreviations">Definitions and Abbreviations</a></h1>
<p id="rfc.section.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">[RFC2119]</a>.  </p>
<p id="rfc.section.2.p.2">Terms and definitions that apply to coding are available in <a href="#nc-taxonomy">[nc-taxonomy]</a>.  More specifically, this document uses the following definitions: </p>

<dl>
  <dt>Packet versus Symbol:</dt>
  <dd style="margin-left: 8">a Packet is the unit of data that is exchanged over the network while a Symbol is the unit of data that is manipulated during the encoding and decoding operations</dd>
  <dt>Source Symbol:</dt>
  <dd style="margin-left: 8">a unit of data originating from the source that is used as input to encoding operations</dd>
  <dt>Repair Symbol:</dt>
  <dd style="margin-left: 8">a unit of data that is the result of a coding operation</dd>
</dl>
<p id="rfc.section.2.p.3">This document uses the following abbreviations: </p>

<dl>
  <dt>E:</dt>
  <dd style="margin-left: 8">size of an encoding symbol (i.e., source or repair symbol), assumed fixed (in bytes)</dd>
</dl>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> General Design Considerations</h1>
<p id="rfc.section.3.p.1">This section lists a few general considerations that govern the framework for FEC coding support in QUIC.  </p>
<h1 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> FEC Code versus FEC Scheme, Block Codes versus Sliding Window Codes</h1>
<p id="rfc.section.3.1.p.1">A FEC code specifies the details of encoding and decoding operations.  In addition to that, a FEC Scheme defines the additional protocol aspects required to use a particular FEC code <a href="#nc-taxonomy">[nc-taxonomy]</a>.  In particular the FEC Scheme defines signaling (e.g., information contained in Source and Repair Packet header or trailers) needed to synchronize encoders and decoders.  </p>
<p id="rfc.section.3.1.p.2">Block coding (e.g., Reed-Solomon <a href="#RFC5510">[RFC5510]</a>) and sliding window coding (e.g., RLC <a href="#RLC">[RLC]</a>) are two broad classes of FEC codes <a href="#nc-taxonomy">[nc-taxonomy]</a>.  In the first case, the input flow must be first segmented into a sequence of blocks, FEC encoding and decoding being performed independently on a per-block basis.  In the second case rely, a sliding encoding window continuously slides over the input flow.  It is envisioned that the two classes of codes could be used to bring FEC protection to QUIC, usually with an advantage for sliding window codes when it comes to low latency communications.  </p>
<h1 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> FEC Scheme Negotiation</h1>
<p id="rfc.section.3.2.p.1">There are multiple FEC Scheme candidates.  Therefore a negotiation step is needed to select one or more codes to be used over a QUIC session.  This will be implemented using the one step negotiation of the new QUIC negotiation mechanism <a href="#QUIC-transport">[QUIC-transport]</a>, during the QUIC handshake.  </p>
<p/>

<dl>
  <dt>Editor's notes:</dt>
  <dd style="margin-left: 4">
    <ul>
      <li>It is likely that FEC Scheme negotiation requires the use of a new dedicated Extension Frame Type. To Be Clarified and text updated.</li>
      <li>It is not clear whether negotiation is meant to select a **single** FEC Scheme or **multiple** FEC Schemes.  In the second case (multiple FEC) it is required to have a complementary mechanism to indicate which FEC Scheme is used in a given REPAIR frame (which could be done through as many REPAIR frame type values as potential FEC Scheme negotiated). Is it what we want to achieve? Not sure.</li>
      <li>It is not clear whether negotiation is carried out at QUIC level (and therefore for multiple streams) or at a stream level (and therefore multiple streams may use multiple FEC Schemes). The terminology used above should be updated to reflect the choice.</li>
    </ul>
  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> FEC Protection Within an Encrypted Channel</h1>
<p id="rfc.section.3.3.p.1">FEC encoding is applied before any QUIC encryption and authentication processing.  Source symbols, that constitute the data units used by the FEC codec, contain cleartext application data.  </p>
<h1 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4.</a> About Middleboxes</h1>
<p id="rfc.section.3.4.p.1">The coding approach described in this document does not allow on path elements (middleboxes) to take part in FEC protection.  The traffic being encrypted end-to-end, the middleboxes are not in position to perform FEC decoding, nor to add any redundant traffic.  </p>
<h1 id="rfc.section.3.5"><a href="#rfc.section.3.5">3.5.</a> FEC Protection at the Stream Level</h1>
<p id="rfc.section.3.5.p.1">Streams in QUIC provide a lightweight, ordered byte-stream abstraction.  FEC encoding is applied at the stream level, within a single stream or across two or more streams of the same QUIC session.  This is motivated by the fact that FEC protection is not necessarily beneficial to all data streams, but only to a subset of them.  For instance FEC protection can be highly beneficial to live video streams to which the proactive erasure correction feature of FEC, independent of the RTT, should be highly beneficial.  On the opposite, FEC protection is probably less attractive for latency insensitive bulk unicast flows.  </p>
<p id="rfc.section.3.5.p.2">In order to facilitate experiments, and in order to enable backward compatibility, the STREAM frames that carry application data are kept unmodified.  On the opposite, frames that carry one or more repair symbols use a dedicated REPAIR frame type, chosen within the type range dedicated to "Extension Frames".  </p>
<h1 id="rfc.section.3.6"><a href="#rfc.section.3.6">3.6.</a> About Gaps in the Set of Source Symbols Considered During Encoding</h1>
<p id="rfc.section.3.6.p.1">A given FEC Scheme MAY support or not the presence of gaps in the set of source symbols that constitute a block (for Block codes) or an encoding window (for Sliding Window codes).  A potential cause for non contiguous sets of source symbols is the acknowledgment of one of them.  When this happens, the QUIC sending endpoint may want to remove this source symbol from further FEC encodings.  This is particularly true with Sliding Window codes because of their flexibility during FEC encoding (i.e., the encoding window can change between two consecutive FEC encodings).  </p>
<p id="rfc.section.3.6.p.2">Supporting gaps can be motivated by the desire to reduce encoding and decoding complexity since there are fewer variables.  However this choice has major consequences in terms of signaling.  Indeed each repair symbol transmitted MUST be accompanied with enough information for the QUIC decoding endpoint to unambiguously identify the exact composition of the block or encoding window.  Without any gap, the identity of the first source symbol plus the number of symbols in the block or encoding window is sufficient.  With gaps, a more complex encoding needs to be used, perhaps similar to the encoding used for selective acknowledgments.  </p>
<p id="rfc.section.3.6.p.3">Whether or not gaps are supported MUST be clarified in each FEC Scheme.  </p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> FEC Scheme Negotiation in QUIC</h1>
<p id="rfc.section.4.p.1">FEC Scheme negotiation has several goals: </p>

<ul>
  <li>Selecting a FEC Scheme (or FEC Schemes) that can be used by the QUIC transmission and reception endpoints.  This process requires an exchange between them;</li>
  <li>Communicating a certain number of parameters that are not expected to change over the session lifetime.  For instance, this is the case of the symbol size parameter, E (in bytes), that needs either to be agreed between the endpoints, or chosen by the sender and communicated to the receiver(s);</li>
</ul>

<p> </p>
<p/>

<dl>
  <dt>Editor's notes:</dt>
  <dd style="margin-left: 4">
    <ul>
      <li>It is likely that FEC Scheme negotiation requires the use of a new dedicated Extension Frame Type. The details remain TBD.</li>
      <li>The Negotiation Frame Type format remains TBD.</li>
      <li>How to communicate the parameters remains TBD.</li>
      <li>The present document only provides high level principles, the details are of course the responsibility of the FEC Scheme.</li>
      <li>In case negotiation is different when protecting a single versus several streams, this section may be moved to the respective sections.</li>
      <li>How does it work in case of a multicast session?</li>
    </ul>
  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> Procedures when Protecting a Single QUIC Stream</h1>
<p id="rfc.section.5.p.1">This section focusses on the simple case where FEC protection is applied to a single QUIC stream.  We consider a unidirectional data flow between a QUIC sending endpoint and one (or more) QUIC reception endpoints.  </p>
<h1 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a> Application data, STREAM Frame data and Source Symbols</h1>
<p id="rfc.section.5.1.p.1">Application data is kept in a transmission buffer at a QUIC sending endpoint, and sent within STREAM frames.  Each STREAM frame that carries data contains an Offset field that indicates the offset within the stream of the first byte of the Stream Data field, as well as a Length field that indicates the number of bytes contained in the Stream Data field.  Upon receiving a STREAM frame, using the Offset and Length fields, a QUIC reception endpoint can easily store data in its reception buffer.  But since a QUIC Packet may be lost during transmission, the reception buffer may have gaps.  </p>
<p><a href="#fig_frame_2_ss_mapping">Figure 1</a> illustrates how source symbols are mapped to the QUIC transmission or reception buffers (same principle on either side).  Since any source (and repair) symbol is of fixed size (E bytes) for a given stream, since QUIC guaranties that the first byte in the stream has an offset of 0, the position of each source symbol is known by both ends.  </p>
<div id="rfc.figure.1"/>
<div id="fig_frame_2_ss_mapping"/>
<pre>
 &lt; -E- &gt; &lt; -E- &gt; &lt; -E- &gt; &lt; -E- &gt;
+-------+-------+-------+-------+
|&lt; -- Frame 1 -- &gt;&lt; ----- Frame |  source symbols 0, 1, 2, 3
+-------+-------+-------+-------+
| 2 ----- &gt;&lt; --- Frame 3 -- &gt;&lt; -|  source symbols 4, 5, 6, 7
+-------+-------+----+--+-------+
| Frame 4 - &gt;&lt; -F5- &gt;|             source symbols 8, 9 and 10
+-------+-------+----+             (incomplete)
</pre>
<p class="figure">Figure 1: Example of source symbol mapping, when the E value is relatively small.</p>
<p id="rfc.section.5.1.p.3">Any value for E is possible, from a single byte to several hundreds or thousands of bytes.  In general, the source symbols are not aligned with data chunks sent in the STREAM frames.  A given STREAM frame may carry all the bytes of a given source symbol.  But when a source symbol straddles two or more (e.g., if E is large compared to usual frame size) STREAM frames, a proper reception of these two (or more) STREAM frames is needed for a QUIC reception endpoint to consider that the source symbol is available for FEC decoding operations.  The choice of an appropriate value for E may depend on the use case (in particular on the nature of application data).  A reasonably small value reduces the probability that a source symbol straddles two or more STREAM frames, a situation that is considered as potentially harmful (the unit of control, the source symbol, and unit of transmission, the frame, are not aligned).  However an overly small value also increases processing complexity (FEC encoding and decoding are performed over a larger linear system) so there is an incentive to use a larger value.  An appropriate balance should be found, and this choice is considered as out of scope for this document.  </p>
<h1 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a> Signaling Considerations within STREAM and REPAIR Frames</h1>
<p id="rfc.section.5.2.p.1">Once the initial negotiation succeeded and an appropriate FEC Scheme has been chosen between the QUIC endpoints, data is exchanged as follows.  Source data is transmitted within STREAM frames, as would happen without any FEC based loss recovery mechanism (in particular without considering source symbols boundaries).  Repair data, computed during FEC encoding, on the opposite, is sent within a dedicated REPAIR frame type, chosen within the type range dedicated to "Extension Frames".  In both cases, the same Stream ID is used since both flows relate to the same stream.  </p>
<p id="rfc.section.5.2.p.2">The REPAIR frame format is FEC Scheme dependent.  The document specifying a FEC Scheme to be used with QUIC MUST define the REPAIR frame format, among other things.  The REPAIR frame MUST carry enough information for a QUIC reception endpoint to understand exactly how this repair symbol(s) has(ve) been generated.  It implies that each REPAIR symbol MUST communicate the block (with block codes) or encoding window (with Sliding Window codes) composition.  This MAY be achieved by communicating in case there is no gap in the source symbol set (see XXX): </p>

<ul>
  <li>the offset of the first source symbol of the block or encoding window;</li>
  <li>the number of source symbols in the block or encoding window, which can be either a number of symbols or a number of bytes since symbols are of fixed size, E.</li>
</ul>

<p> Note that unlike FEC Schemes for FLUTE/ALC, NORM, and FECFRAME, here there is no notion of Encoding Symbol Id (ESI), an identifier managed in a sequential manner to identify source and repair symbols.  The use of an offset within the stream, with the guaranty that no wrapping to zero can occur, provides an alternative mechanism to identify any source symbol.  </p>
<p id="rfc.section.5.2.p.3">As explained above, source data is transmitted without any modification, which provides backward compatibility.  This is advantage in situations where the same QUIC stream is delivered to several QUIC reception endpoints (multicast): it may be appropriate to select a given FEC Scheme even if it is known that a subset of the QUIC reception endpoints do not support it.  </p>
<p/>

<dl>
  <dt>Editor's notes:</dt>
  <dd style="margin-left: 4">
    <ul>
      <li>This I-D proposes to define a single generic REPAIR frame type, but an alternative could be to have a one-to-one mapping between a REPAIR frame type and a specific FEC Scheme.</li>
      <li>The use of frame type within the Extension Frames range for REPAIR frames is meant to facilitate experimentations.  If the use of coding in QUIC is recognized as having benefits, a dedicated (or more, see above) frame type could be selected later on.</li>
    </ul>
  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3.</a> Management of Silent Periods and End of Stream</h1>
<p id="rfc.section.5.3.p.1">If an application does not submit fresh data for some time, the last source symbol may not be totally filled.  It follows that this last source symbol cannot be considered during FEC encoding and therefore the associated bytes of the application stream are not protected.  A similar problem arrives when a stream is finished, the application having no more data to submit to QUIC.  Here also, the bytes of the last incomplete source symbol are not protected by FEC encoding.  </p>
<p id="rfc.section.5.3.p.2">In order to solve this problem, it is RECOMMENDED that a QUIC sending endpoint: </p>

<ul>
  <li>Identifies when such a situation is likely to occur, for instance by waiting no more than a certain time during an application silent period;</li>
  <li>Upon time-out, the application falls back to the alternative re-transmission based loss recovery mechanism for the bytes of the last incomplete source symbol;</li>
</ul>

<p> </p>
<p/>

<dl>
  <dt>Editor's notes:</dt>
  <dd style="margin-left: 4">Clearly, the above mechanism requires more thoughts as well as experimental work.  The "end of stream" situation may be addressed through zero padding perhaps easily.  However the use of zero padding for transitory silent periods may add a lot of specification and implementation complexity...</dd>
</dl>

<p> </p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> Procedures when Protecting Several QUIC Streams</h1>
<p id="rfc.section.6.p.1">This section focusses on the general case where FEC protection is globally applied across two or more QUIC streams.  </p>
<p/>

<dl>
  <dt>Editor's notes:</dt>
  <dd style="margin-left: 4">It is not clear whether this use-case is needed.  It adds specification and implementation complexity that need to be balanced with the expected benefits.  <ul><li>Receiver: A first complexity comes from the requirement to identify to which stream a decoded source symbol belongs to.  This is also one of the main difficulty for FECFRAME (both with block and sliding window codes) which required to distinguish an ADU (submitted by the application) from an ADUI (the same ADU plus an additional FlowID among other things).  Do we want this level of complexity?</li><li>Sender: Another complexity comes from the encoding window management at a sender. With multiple streams, shifting the encoding window to the right needs to be done based on timestamps associated to source symbols of the various streams: the oldest source symbol across all the streams will be removed.  </li><li>When two largely different streams are protected togethers (e.g., a high definition 4K video flow plus the associated relatively low-rate audio stream), is this extra complexity balanced by significant performance improvements compared to an independent protection on each stream (intuition is yes, the low bitrate flow is better protected iff the encoding window is large enough)? And when the various streams have a comparable bitrate? More work (incl. experimental work) is needed to answer this question.</li></ul><p> </p></dd>
</dl>

<p> </p>
<h1 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> Application data, STREAM Frame data and Source Symbols</h1>
<p id="rfc.section.6.1.p.1">Within each stream, the source symbols MUST be defined as in the simple case of a single stream.  <a href="#fig_frame_2_ss_mapping">Figure 1</a> remains valid.  </p>
<h1 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> Block or Encoding Window Management</h1>
<p id="rfc.section.6.2.p.1">The details of how to create the block or encoding window are specific to the FEC Scheme.  A possible approach is the following.  </p>
<p id="rfc.section.6.2.p.2">When creating the block (block FEC code) or encoding window (sliding window FEC code), the source symbols to consider of each stream are appended.  All the relevant source symbols of the first stream are appended, followed by all the source symbols of the second stream, etc.  These sequences do not follow any timing consideration in order to simplify signaling.  </p>
<p><a href="#fig_ew_across_2_streams">Figure 2</a> illustrates, in case of a Sliding Window FEC Scheme, an encoding window with source symbols belonging to two streams, of Stream ID 120 and 51 respectively.  </p>
<div id="rfc.figure.2"/>
<div id="fig_ew_across_2_streams"/>
<pre>
&lt; ----------- Stream ID 120 ---------- &gt; &lt; --- Stream ID 51 --- &gt;
+-------+-------+-------+-------+-------+-------+-------+-------+
|       |       |       |       |       |       |       |       |
+-------+-------+-------+-------+-------+-------+-------+-------+
 ^       &lt; -E- &gt;                         ^
 |                                       |
offset = 0x42f0, length = 5*E       offset = 0x0f24, length = 3*E
</pre>
<p class="figure">Figure 2: Example of encoding window of a Sliding Window FEC Scheme and FEC protection across two streams.</p>
<h1 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a> Signaling Considerations within STREAM and REPAIR Frames</h1>
<p id="rfc.section.6.3.p.1">Source data on each stream is transmitted within STREAM frames, as would happen without any FEC based loss recovery mechanism.  </p>
<p id="rfc.section.6.3.p.2">Repair symbols, generated during FEC encoding as a linear combination of source symbols that belong to one or more of the streams, are transmitted within REPAIR frames.  Each REPAIR frame can be associated to any of the input streams it protects, and therefore associated to any of the associated Stream IDs.  </p>
<p/>

<dl>
  <dt>Editor's notes:</dt>
  <dd style="margin-left: 4">Check that indeed, with FEC protection across several streams, assigning a REPAIR frame to any of the streams it protects is meaningful.  Should an approach for selecting one stream (and Stream ID) be preferred?</dd>
</dl>

<p> </p>
<p id="rfc.section.6.3.p.4">The REPAIR frame format is FEC Scheme dependent and MUST be defined by document specifying a FEC Scheme.  One of the key information of this REPAIR frame is the composition of the block (with block codes) or encoding window (with sliding window codes) used to perform FEC encoding.  Indeed, this is the only manner to convey this information since an application flow is not predictable (e.g., if an application flow is momentarily suspended, the composition of the block or encoding window will be affected).  One possibility is to list, in each REPAIR frame header: </p>

<ul>
  <li>the actual number of streams considered (the maximum number is known after the negotiation step, but if one of the streams remains silent for some time, it may not contribute during encoding and therefore be absent from the block or encoding window); </li>
  <li>for each stream concerned, its Stream ID, the offset of the first source symbol considered as well as the length, i.e., the number of bytes considered.</li>
</ul>

<p> This approach does not enable to keep track of the source symbol ordering across streams, but enables a non ambiguous description of the encoding window.  </p>
<p id="rfc.section.6.3.p.5">The FEC Scheme specification MUST also detail how to manage the block or encoding window.  For instance, should the oldest source symbol of any stream be removed from the encoding window when this latter is shifted to the right? This would mean that a timestamp is attached to each source symbol in order to identify the oldest one across all streams.  </p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> Security Considerations</h1>
<p id="rfc.section.7.p.1">TBD </p>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#iana" id="iana">IANA Considerations</a></h1>
<p id="rfc.section.8.p.1">TBD </p>
<h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a> Acknowledgments</h1>
<p id="rfc.section.9.p.1">TBD </p>
<h1 id="rfc.references"><a href="#rfc.references">10.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">10.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="QUIC-transport">[QUIC-transport]</b>
      </td>
      <td class="top"><a title="Fastly">Iyengar, J.</a> and <a title="Mozilla">M. Thomson</a>, "<a href="http://tools.ietf.org/html/draft-ietf-quic-transport-12">QUIC: A UDP-Based Multiplexed and Secure Transport</a>", Internet-Draft draft-ietf-quic-transport-12, May 2018.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">10.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC5510">[RFC5510]</b>
      </td>
      <td class="top"><a>Lacan, J.</a>, <a>Roca, V.</a>, <a>Peltotalo, J.</a> and <a>S. Peltotalo</a>, "<a href="http://tools.ietf.org/html/rfc5510">Reed-Solomon Forward Error Correction (FEC) Schemes</a>", RFC 5510, DOI 10.17487/RFC5510, April 2009.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RLC">[RLC]</b>
      </td>
      <td class="top"><a>Roca, V.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tsvwg-rlc-fec-scheme">Sliding Window Random Linear Code (RLC) Forward Erasure Correction (FEC) Scheme for FECFRAME</a>", Work in Progress, Transport Area Working Group (TSVWG) draft-ietf-tsvwg-rlc-fec-scheme (Work in Progress), May 2018.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="nc-taxonomy">[nc-taxonomy]</b>
      </td>
      <td class="top"><a title="INRIA">Roca et al., V.</a>, "<a href="http://tools.ietf.org/html/draft-irtf-nwcrg-network-coding-taxonomy (Work in Progress)">Taxonomy of Coding Techniques for Efficient Network Communications</a>", Internet-Draft draft-irtf-nwcrg-network-coding-taxonomy (Work in Progress), March 2018.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Ian Swett</span> 
	  <span class="n hidden">
		<span class="family-name">Swett</span>
	  </span>
	</span>
	<span class="org vcardline">Google</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality">Cambridge</span>,  
		<span class="region">MA</span> 
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">US</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ianswett@google.com">ianswett@google.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Marie-Jose Montpetit</span> 
	  <span class="n hidden">
		<span class="family-name">Montpetit</span>
	  </span>
	</span>
	<span class="org vcardline">Triangle Video</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality">Boston</span>,  
		<span class="region">MA</span> 
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">US</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:marie@mjmontpetit.com">marie@mjmontpetit.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Vincent Roca</span> 
	  <span class="n hidden">
		<span class="family-name">Roca</span>
	  </span>
	</span>
	<span class="org vcardline">INRIA</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality">Univ. Grenoble Alpes</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">France</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:vincent.roca@inria.fr">vincent.roca@inria.fr</a></span>

  </address>
</div>

</body>
</html>
