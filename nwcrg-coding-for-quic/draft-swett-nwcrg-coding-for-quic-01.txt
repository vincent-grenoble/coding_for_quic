



nwcrg                                                           I. Swett
Internet-Draft                                                    Google
Intended status: Informational                            M-J. Montpetit
Expires: December 2, 2018                                 Triangle Video
                                                                 V. Roca
                                                                   INRIA
                                                            May 31, 2018


                            Coding for QUIC
                  draft-swett-nwcrg-coding-for-quic-01

Abstract

   This document focusses on the integration of FEC coding in the QUIC
   transport protocol in order to recover from packet losses in QUIC
   sessions.  This document does not specify any code but defines
   mechanisms to negociate and integrate FEC Schemes in QUIC.  By using
   proactive loss recovery, it is expected to improve QUIC performance
   in sessions impacted by losses.  More precisely it is expected to
   improve QUIC performance with real-time sessions (since FEC coding
   makes packet loss recovery insensitive to RTT), with multicast
   sessions when applicable (since the same repair packet can recover
   several different losses at several receivers), and with multipath
   sessions when applicable (since the same repair packet protects
   several packets).

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on December 2, 2018.








Swett, et al.           Expires December 2, 2018                [Page 1]

Internet-Draft               Coding for QUIC                    May 2018


Copyright Notice

   Copyright (c) 2018 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
   2.  Definitions and Abbreviations . . . . . . . . . . . . . . . .   3
   3.  General Design Considerations . . . . . . . . . . . . . . . .   4
     3.1.  FEC Code versus FEC Scheme, Block Codes versus Sliding
           Window Codes  . . . . . . . . . . . . . . . . . . . . . .   4
     3.2.  FEC Scheme Negotiation  . . . . . . . . . . . . . . . . .   4
     3.3.  FEC Protection Within an Encrypted Channel  . . . . . . .   5
     3.4.  FEC Protection at the Stream Level  . . . . . . . . . . .   5
     3.5.  About Gaps in the Set of Source Symbols Considered During
           Encoding  . . . . . . . . . . . . . . . . . . . . . . . .   5
   4.  FEC Scheme Negotiation in QUIC  . . . . . . . . . . . . . . .   6
   5.  Procedures when Protecting a Single QUIC Stream . . . . . . .   6
     5.1.  Application data, STREAM Frame data and Source Symbols  .   7
     5.2.  Signaling Considerations within STREAM and REPAIR Frames    8
     5.3.  Management of Silent Periods and End of Stream  . . . . .   8
   6.  Procedures when Protecting Several QUIC Streams . . . . . . .   9
     6.1.  Application data, STREAM Frame data and Source Symbols  .  10
     6.2.  Block or Encoding Window Management . . . . . . . . . . .  10
     6.3.  Signaling Considerations within STREAM and REPAIR Frames   10
   7.  Security Considerations . . . . . . . . . . . . . . . . . . .  11
   8.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  11
   9.  Acknowledgments . . . . . . . . . . . . . . . . . . . . . . .  12
   10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  12
     10.1.  Normative References . . . . . . . . . . . . . . . . . .  12
     10.2.  Informative References . . . . . . . . . . . . . . . . .  12
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  12








Swett, et al.           Expires December 2, 2018                [Page 2]

Internet-Draft               Coding for QUIC                    May 2018


1.  Introduction

   QUIC is a new transport that wants to improve network performance by
   enabling out of order delivery, partial reliability, and methods of
   recovery besides retransmission while also improving security.  This
   document specifies a framework to enable FEC codes to be used to
   recover from lost packets within a single QUIC stream or across
   several QUIC streams.

   The ability to add FEC coding in QUIC could be benefic in the
   following situations:

   o  robust transmission of latency sensitive traffic, for instance
      real-time flows, since it enables to recover packet losses
      independantly of the round trip time;

   o  transmission of content to a large set of QUIC reception
      endpoints, since the same repair content may help recovering
      several different packet losses at different receivers;

   o  use along with multipath communications, since repair traffic adds
      diversity.

   The design does not mandate the use of any specific FEC code (that
   specifies how to do encoding and decoding) nor FEC Scheme (that
   specifies both a FEC code but also a manner to use this code in
   particular in terms of signaling).  Instead it allows to negotiate
   the FEC code to use at session startup, assuming that more than one
   code could potentially be offered concurrently.  Without loss of
   generality in the document we consider that the encoding operations
   compute a linear combination of QUIC packets, regardless of whether
   these codes are of block type (as with Reed-Solomon codes [RFC5510])
   or sliding window type (as with RLC codes).  Terms and definitions
   that apply to coding are available in [nc-taxonomy].

2.  Definitions and Abbreviations

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].

   This document uses the following definitions and abbreviations:

   E: size of an encoding symbol (i.e., source or repair symbol),
      assumed fixed (in bytes)






Swett, et al.           Expires December 2, 2018                [Page 3]

Internet-Draft               Coding for QUIC                    May 2018


3.  General Design Considerations

   This section lists a few general considerations that govern the
   framework for FEC support in QUIC.

3.1.  FEC Code versus FEC Scheme, Block Codes versus Sliding Window
      Codes

   A FEC Scheme defines the additional protocol aspects required to use
   a particular FEC code [nc-taxonomy].  In particular the FEC Scheme
   defines signaling (e.g., information contained in Source and Repair
   Packet header or trailers) needed to synchronize encoders and
   decoders.  Adding FEC protection to QUIC requires a FEC Scheme
   specification to be available that not only defines how to perform
   encoding and decoding (i.e., the code specification, that can be re-
   used from another specification of this FEC code) but also all the
   surrounded aspects that enable its use along with QUIC.

   Block coding (e.g., Reed-Solomon) and sliding window coding (e.g.,
   RLC) are two general classes of FEC codes [nc-taxonomy].  In the
   first case, the input flow must be first segmented into a sequence of
   blocks, FEC encoding and decoding being performed independently on a
   per-block basis.  In the second case rely, a sliding encoding window
   continuously slides over the input flow.  It is envisionned that the
   two classes of codes could be used to bring FEC protection to QUIC.

3.2.  FEC Scheme Negotiation

   There are already multiple FEC Scheme candidates and others may
   become available in the future.  Therefore it is assumed that a
   negotiation will be implemented to select one or more codes to be
   used over a QUIC session.  This will be implemented using the one
   step negotiation of the new QUIC negotiation mechanism
   [QUIC-transport], during the QUIC handshake.

   Editor's notes:

       *  It is not clear whether negotiation is meant to select a
          single FEC Scheme or multiple potential FEC Schemes.  In the
          second case (multiple FEC) it is required to have a
          complementary mechanism to indicate which FEC Scheme is used
          in a given REPAIR frame (which could be done through as many
          REPAIR frame type values as potential FEC Scheme negotiated).

       *  It is not clear whether negotiation is carried out at QUIC
          level (and therefore for multiple streams) or at a stream
          level (and therefore multiple streams may use multiple FEC




Swett, et al.           Expires December 2, 2018                [Page 4]

Internet-Draft               Coding for QUIC                    May 2018


          Schemes).  The terminology used above should be updated to
          reflect the choice.

       *  It is likely that FEC Scheme negotiation requires the use of a
          new dedicated Extension Frame Type.  The details remain TBD.

3.3.  FEC Protection Within an Encrypted Channel

   FEC encoding is applied before any QUIC encryption and authentication
   processing.  Source symbols, that constitute the data units used by
   the FEC codec, contain cleartext application data.  A consequence of
   this approach is that it does not enable non-participating
   middleboxes to perform FEC encoding or decoding operation.

   Coding should be applied to all QUIC packets except the 0RTT
   payloads.  0RTT payloads are sent prior to negotiation, and the QUIC
   negotiation mechanism does not allow sending extension frames prior
   to handshake completion.

3.4.  FEC Protection at the Stream Level

   FEC encoding is applied at the stream level, within a single stream
   or accross two or more streams of the same QUIC session.  This is
   motivated by the fact that FEC protection is not necessarily benefic
   to all data streams, but only to a subset of them.  For instance FEC
   protection can be highly benefic to live video streams whose real-
   time requirements for which the proactive erasure correction feature
   of FEC, independant of the RTT, should be highly beneficial.  On the
   opposite, FEC protection is probably less attractive for latency
   insensitive bulk flows.

   In order to facilitate experiments, and in order to enable backward
   compatibility, the STREAM frames that carry application data are kept
   unmodified.  On the opposite, frames that carry one or more repair
   symbols use a dedicated REPAIR frame type, chosen within the type
   range dedicated to "Extension Frames".

3.5.  About Gaps in the Set of Source Symbols Considered During Encoding

   A given FEC Scheme MAY support or not the presence of gaps in the set
   of source symbols that constitute a block (for Block codes) or an
   encoding window (for sliding window codes).  A potential reason for
   non contiguous sets of source symbols is the acknowledgment of a
   source symbol.  When this is the case the QUIC sending endpoint MAY
   want to remove this source symbol from further FEC encodings.  This
   is particularly true with Sliding Window codes because of their
   flexibility during FEC encoding (the encoding window can change
   between two consecutive FEC encodings).



Swett, et al.           Expires December 2, 2018                [Page 5]

Internet-Draft               Coding for QUIC                    May 2018


   Supporting the presence of gaps could be motivated by a desire to
   reduce encoding and decoding complexity.  However this choice can
   have major consequences in terms of signaling.  Indeed each repair
   symbol transmitted MUST be accompanied with enough information for
   the QUIC decoding endpoint to unambiguously identify the exact
   composition of the block or encoding window.  Without any gap, the
   identity of the first source symbol plus the number of symbols in the
   block or encoding window is sufficient.  With gaps, a more complex
   encoding will have to be used, perhaps similar to the encoding used
   for selective acknowledgments.

   Whether or not gaps are supported MUST be clarified in each FEC
   Scheme.

4.  FEC Scheme Negotiation in QUIC

   FEC Scheme negotiation has several goals:

   o  Selecting a FEC Scheme (or FEC Schemes) that can be used by both
      the QUIC transmission endpoint and QUIC reception endpoint(s).
      This process requires an exchange between the QUIC endpoints;

   o  Communicating a certain number of parameters that are not expected
      to change over the session lifetime.  For instance, this is the
      case of the symbol size parameter, E, that needs to be agreed
      between the endpoints, or chosen by the sender and communicated to
      the receiver(s);

   Editor's notes:

       *  It is likely that FEC Scheme negotiation requires the use of a
          new dedicated Extension Frame Type.  The details remain TBD.

       *  The Negotiation Frame Type format remains TBD.

       *  How to communicate the parameters remains TBD.

       *  In case negotiation is different when protecting a single
          versus several streams, this section should be moved to the
          respective sections.

5.  Procedures when Protecting a Single QUIC Stream

   Streams in QUIC provide a lightweight, ordered byte-stream
   abstraction.  Hereafter we consider a unidirectional data flow
   between a QUIC sending endpoint and one (or more) QUIC reception
   endpoints.  Without any loss of generality, the case of bidirectional
   flows will be considered as several independant unidirectional flows.



Swett, et al.           Expires December 2, 2018                [Page 6]

Internet-Draft               Coding for QUIC                    May 2018


   This section focusses on the simple case where FEC protection is
   applied to a single QUIC stream.

5.1.  Application data, STREAM Frame data and Source Symbols

   Application data is kept in a transmission buffer at a QUIC sending
   endpoint, and sent within STREAM frames.  Each STREAM frame that
   carries data contains an Offset field that indicates the offset
   within the stream of the first byte of data, as well as a Length
   field that indicates the number of bytes contained in the Stream Data
   field.  Upon receiving a STREAM frame, using the Offset and Lenght
   fields, a QUIC reception endpoint can easily copy data in its
   reception buffer.  Because a QUIC Packet may be lost during
   transmission, the reception buffer may have gaps.

   Figure 1 illustrates how source symbols are mapped to the QUIC
   transmission or reception buffers.  Since any source (and repair)
   symbol is of fixed size (E bytes) for a given stream, since QUIC
   guarranties that the first byte in the stream has an offset of 0, the
   position of each source symbol is known.

    < -E- > < -E- > < -E- > < -E- >
   +-------+-------+-------+-------+
   |< -- Frame 1 -- >< ----- Frame |  source symbols 0, 1, 2, 3
   +-------+-------+-------+-------+
   | 2 ----- >< --- Frame 3 -- >< -|  source symbols 4, 5, 6, 7
   +-------+-------+----+--+-------+
   | Frame 4 - >< -F5- >|             source symbols 8, 9 and 10
   +-------+-------+----+             (incomplete)

      Figure 1: Example of source symbol mapping, when the E value is
                             relatively small.

   Any value for E is possible, from a single byte to several hundreds
   or thousands of bytes.  In general, the source symbols are not
   aligned with data chunks sent in the STREAM frames.  It means that a
   given STREAM frame may carry all the bytes of a given source symbol.
   On the opposite, when a source symbol straddles two (or even more if
   E is large compared to usual frame sizes) STREAM frames, a proper
   reception of these two (or more) STREAM frames is needed for a QUIC
   reception endpoint to consider that the source symbol is available
   for FEC operations.  The choice of an appropriate value for E may
   depend on the use case (in particular on the nature of application
   data).  Having a reasonably small value reduces the probability (but
   cannot prevent) that a source symbol straddles two (or even more)
   STREAM frames, a situation that is considered as potentially harmful
   (the unit of control, the source symbol, and unit of transmission,
   the frame, are not aligned).  However an overly small value also



Swett, et al.           Expires December 2, 2018                [Page 7]

Internet-Draft               Coding for QUIC                    May 2018


   increases processing complexity (FEC encoding and decoding are
   performed over larger linear systems).  An appropriate balance should
   be found.  The choice of a value for E is considered as out of scope
   for this document.

5.2.  Signaling Considerations within STREAM and REPAIR Frames

   Once the initial negociation succeeded and an appropriate FEC Scheme
   chosen between the QUIC endpoints, data is exchanged as follows.
   Source data is transmitted within STREAM frames, as would happen
   without any FEC based loss recovery mechanism.  Repair data, computed
   during FEC encoding, on the opposite, is sent within a dedicated
   REPAIR frame type, chosen within the type range dedicated to
   "Extension Frames".  In both cases, the same Stream ID is used since
   both flows relate to the same stream.

   The REPAIR frame format is FEC Scheme dependent.  The document
   specifying a FEC Scheme to be used with QUIC MUST define the REPAIR
   frame format, among other things.

   As explained above, source data is transmitted without any
   modification.  From this point of view, the use of FEC coding in QUIC
   does not prevent backward compatibility.  This is advantage in
   situations where the same QUIC stream is delivered to several QUIC
   reception endpoints (multicast).  Even if the use of FEC coding is
   negotiated as stream startup, it may be appropriate to select a given
   FEC Scheme even if it is known that a subset of the QUIC reception
   endpoints do not support it.

   Editor's notes:  Several aspects remain TBD.

       *  This I-D proposes to define a single generic REPAIR frame
          type, but an alternative could be to have a one-to-one mapping
          between a REPAIR frame type and a specific FEC Scheme.

       *  The use of frame type within the Extension Frames range is
          meant to facilitate experimentations.  If the use of coding in
          QUIC is recognized as having benefits, a dedicated (or more,
          see above) frame type could be selected.

5.3.  Management of Silent Periods and End of Stream

   If no application data is submitted on the stream for some time, the
   last source symbol may not be filled with application data.  It
   follows that this last source symbol cannot be considered during FEC
   encoding and therefore the associated bytes of the application stream
   are not protected.  A similar problem arrives when a stream is
   finished, the application having no more data to transmit.  Here



Swett, et al.           Expires December 2, 2018                [Page 8]

Internet-Draft               Coding for QUIC                    May 2018


   also, in the general case, the last source symbol will not be filled
   and therefore the associated bytes of the application stream are not
   protected.

   In order to solve this problem, it is RECOMMENDED that a QUIC sending
   endpoint:

   o  Identifies when such a situation is likely to occur, waiting no
      more than a certain time during an application silent period;

   o  Upon time-out, the application falls back to the alternative re-
      transmission based loss recovery mechanism for the bytes of the
      last uncomplete source symbol;

   Editor's notes:  Clearly, the above mechanism requires more thoughts
       as well as experimental work.  The "end of stream" situation may
       be addressed through zero padding perhaps easily.  However the
       use of zero padding for transitory silent periods may add a lot
       of specification and implementation complexity.  This aspect
       needs more thoughts.

6.  Procedures when Protecting Several QUIC Streams

   This section focusses on the general case where FEC protection is
   globally applied across two or more QUIC streams.

   Editor's notes:  It is not clear whether this use-case is needed.  It
       adds specification and implementation complexity that need to be
       balanced with the expected benefits.

       *  Receiver: A first complexity comes from the requirement to
          identify to which stream a decoded source symbol belongs to.
          This is also one of the main difficulty for FECFRAME (both
          with block and sliding window codes) which required to
          distinguish an ADU (submitted by the application) from an ADUI
          (the same ADU plus an additional FlowID among other things).
          Do we want this level of complexity?

       *  Sender: Another complexity comes from the encoding window
          management at a sender.  With multiple streams, shifting the
          encoding window to the right needs to be done based on
          timestamps associated to source symbols of the various
          streams: the oldest source symbol across all the streams will
          be removed.

       *  When two largely different streams are protected togethers
          (e.g., a high definition 4K video flow plus the associated
          relatively low-rate audio stream), is this extra complexity



Swett, et al.           Expires December 2, 2018                [Page 9]

Internet-Draft               Coding for QUIC                    May 2018


          balanced by significant performance improvements compared to
          an independant protection on each stream (intuition is yes,
          the low bitrate flow is better protected iff the encoding
          window is large enough)?  And when the various streams have a
          comparable bitrate?  More work (incl. experimental work) is
          needed to answer this question.

6.1.  Application data, STREAM Frame data and Source Symbols

   Within each stream, the source symbols MUST be defined as in the
   simple case of a single stream.  Figure 1 remains valid.

6.2.  Block or Encoding Window Management

   The details of how to create the block or encoding window are
   specific to the FEC Scheme.  A possible approach is the following.

   When creating the block (block FEC code) or encoding window (sliding
   window FEC code), the source symbols to consider of each stream are
   appended.  All the relevent source symbols of the first stream are
   appended, followed by all the source symbols of the second stream,
   etc.  These sequences do not follow any timing consideration in order
   to simplify signaling.

   Figure 2 illustrates, in case of a Sliding Window FEC Scheme, an
   encoding window with source symbols belonging to two streams, of
   Stream ID 120 and 51 respectively.

   < ----------- Stream ID 120 ---------- > < --- Stream ID 51 --- >
   +-------+-------+-------+-------+-------+-------+-------+-------+
   |       |       |       |       |       |       |       |       |
   +-------+-------+-------+-------+-------+-------+-------+-------+
    ^       < -E- >                         ^
    |                                       |
   offset = 0x42f0, length = 5*E       offset = 0x0f24, length = 3*E

    Figure 2: Example of encoding window of a Sliding Window FEC Scheme
                  and FEC protection across two streams.

6.3.  Signaling Considerations within STREAM and REPAIR Frames

   Source data on each stream is transmitted within STREAM frames, as
   would happen without any FEC based loss recovery mechanism.

   Repair symbols, generated during FEC encoding as a linear combination
   of source symbols that belong to one or more of the streams, are
   transmitted within REPAIR frames.  Each REPAIR frame can be




Swett, et al.           Expires December 2, 2018               [Page 10]

Internet-Draft               Coding for QUIC                    May 2018


   associated to any of the input streams it protects, and therefore
   associated to any of the associated Stream IDs.

   Editor's notes:  Check that indeed, with FEC protection across
       several streams, assigning a REPAIR frame to any of the streams
       it protects is meaningful.  Should an approach for selecting one
       stream (and Stream ID) be prefered?

   The REPAIR frame format is FEC Scheme dependent and MUST be defined
   by document specifying a FEC Scheme.  One of the key information of
   this REPAIR frame is the composition of the block (with block codes)
   or encoding window (with sliding window codes) used to perform FEC
   encoding.  Indeed, this is the only manner to convey this information
   since an application flow is not predictible (e.g., if an application
   flow is momentarily suspended, the composition of the block or
   encoding window will be affected).  One possibility is to list, in
   each REPAIR frame header:

   o  the actual number of streams considered (the maximum number is
      known after the negotiation step, but if one of the streams
      remains silent for some time, it may not contribute during
      encoding and therefore be absent from the block or encoding
      window);

   o  for each stream concerned, its Stream ID, the offset of the first
      source symbol considered as well as the length, i.e., the number
      of bytes considered.

   This approach does not enable to keep track of the source symbol
   ordering across streams, but enables a non ambiguous description of
   the encoding window.

   The FEC Scheme specification MUST also detail how to manage the block
   or encoding window.  For instance, should the oldest source symbol of
   any stream be removed from the encoding window when this latter is
   shifted to the right?  This would mean that a timestamp is attached
   to each source symbol in order to identify the oldest one across all
   streams.

7.  Security Considerations

   TBD

8.  IANA Considerations

   TBD





Swett, et al.           Expires December 2, 2018               [Page 11]

Internet-Draft               Coding for QUIC                    May 2018


9.  Acknowledgments

   TBD

10.  References

10.1.  Normative References

   [QUIC-transport]
              Iyengar, J., Ed. and M. Thomson, Ed., "QUIC: A UDP-Based
              Multiplexed and Secure Transport", draft-ietf-quic-
              transport-12 (work in progress), May 2018,
              <https://datatracker.ietf.org/doc/draft-ietf-quic-
              transport/>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, DOI 10.17487/
              RFC2119, March 1997,
              <http://www.rfc-editor.org/info/rfc2119>.

10.2.  Informative References

   [RFC5510]  Lacan, J., Roca, V., Peltotalo, J., and S. Peltotalo,
              "Reed-Solomon Forward Error Correction (FEC) Schemes", RFC
              5510, DOI 10.17487/RFC5510, April 2009, <https://www.rfc-
              editor.org/info/rfc5510>.

   [nc-taxonomy]
              Roca et al., V., "Taxonomy of Coding Techniques for
              Efficient Network Communications", draft-irtf-nwcrg-
              network-coding-taxonomy-08 (work in progress), March 2018,
              <https://datatracker.ietf.org/doc/draft-irtf-nwcrg-
              network-coding-taxonomy/>.

Authors' Addresses

   Ian Swett
   Google
   Cambridge, MA
   US

   Email: ianswett@google.com









Swett, et al.           Expires December 2, 2018               [Page 12]

Internet-Draft               Coding for QUIC                    May 2018


   Marie-Jose Montpetit
   Triangle Video
   Boston, MA
   US

   Email: marie@mjmontpetit.com


   Vincent Roca
   INRIA
   Univ. Grenoble Alpes
   France

   Email: vincent.roca@inria.fr





































Swett, et al.           Expires December 2, 2018               [Page 13]
