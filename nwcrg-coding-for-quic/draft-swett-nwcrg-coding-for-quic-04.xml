<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
    which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
    There has to be one entity for each item to be referenced.
    An alternate method (rfc include) is described in the references. -->

<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC8312 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8312.xml">
<!ENTITY RFC2629 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2629.xml">
<!-- <!ENTITY RFC3452 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3452.xml"> -->
<!ENTITY RFC5510 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5510.xml">
<!ENTITY RFC8681 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8681.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
    please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
    (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
    (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="info" docName="draft-swett-nwcrg-coding-for-quic-04" ipr="trust200902">
 <!-- category values: std, bcp, info, exp, and historic
    ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
       or pre5378Trust200902
    you can add the attributes updates="NNNN" and obsoletes="NNNN"
    they will automatically be output with "(if approved)" -->

 <!-- ***** FRONT MATTER ***** -->

<front>

   <title abbrev="Coding for QUIC">Coding for QUIC</title>

   <author fullname="Ian Swett" initials="I." surname="Swett">
     <organization>Google</organization>
     <address>
       <postal>
         <street></street>
         <city>Cambridge</city>
         <region>MA</region>
         <code></code>
         <country>US</country>
       </postal>
       <phone></phone>
       <email>ianswett@google.com</email>
     </address>
   </author>

  <author fullname="Marie-Jose Montpetit" initials="M-J." surname="Montpetit">
     <organization>Triangle Video</organization>
     <address>
       <postal>
         <street></street>
         <city>Boston</city>
         <region>MA</region>
         <code></code>
         <country>US</country>
       </postal>
       <phone></phone>
       <email>marie@mjmontpetit.com</email>
     </address>
   </author>

   <author fullname="Vincent Roca" initials="V." surname="Roca">
     <organization>INRIA</organization>
     <address>
       <postal>
         <street></street>
         <city>Univ. Grenoble Alpes</city>
         <region></region>
         <code></code>
         <country>France</country>
       </postal>
       <phone></phone>
       <email>vincent.roca@inria.fr</email>
     </address>
   </author>

   <author fullname="Francois Michel" initials="F." surname="Michel">
     <organization>UCLouvain</organization>
     <address>
       <postal>
         <street></street>
         <city>Louvain-la-Neuve</city>
         <region></region>
         <code></code>
         <country>Belgium</country>
       </postal>
       <phone></phone>
       <email>francois.michel@uclouvain.be</email>
     </address>
   </author>

   <date/>

   <area>IRTF</area>

   <workgroup>nwcrg</workgroup>

   <keyword>QUIC, loss recovery, FEC coding, frame format, negotiation</keyword>

   <abstract>
<t>
This document focuses on the integration of FEC coding in the QUIC transport protocol, in order to recover from packet losses.
This document does not specify any FEC code but defines mechanisms to negotiate and integrate FEC Schemes in QUIC.
By using proactive loss recovery, it is expected to improve QUIC performance in sessions impacted by packet losses.
More precisely it is expected to improve QUIC performance with real-time sessions (since FEC coding makes packet loss recovery insensitive to the round trip time), with short sessions (since FEC coding can help recovering from tail losses more rapidely than through retransmissions), with multicast sessions (since the same repair packet can recover several different losses at several receivers), and with multipath sessions (since repair packets add diversity and flexibility).
</t>
   </abstract>

</front>

<middle>

    <section title="Introduction">
    <!-- ====================== -->

<t>
QUIC is a new transport that aims at improving network performance by enabling out of order delivery, partial reliability, and methods of recovery besides retransmission, while also improving security.
This document specifies a framework to enable FEC codes to be used to recover from lost packets within a single QUIC stream or across several QUIC streams.
</t>

<t>
The ability to add FEC coding in QUIC may be beneficial in several situations:
<list style="symbols">
    <t>for a robust transmission of latency sensitive traffic, for instance real-time flows, since it enables to recover packet losses independently of the round trip time;</t>
    <t>for short sessions, in order to protect the last few packets sent, since it enables to recover from tail losses more rapidely than through retransmissions;</t>
    <t>for the transmission of contents to a large set of QUIC reception endpoints, since the same repair frame may help recovering several different packet losses at different receivers;</t>
    <t>for multipath communications, since repair traffic adds diversity and flexibility.</t>
</list>
</t>

<t>
This framework does not mandate the use of any specific FEC code (i.e., how to encode and decode) nor FEC Scheme (i.e., that specifies both a FEC code and how to use it, in particular in terms of signaling).
Instead it allows to negotiate the FEC Scheme to use at session startup, assuming that more than one solution could potentially be offered concurrently.
Without loss of generality, we assume that the encoding operations compute a linear combination of QUIC packets, regardless of whether these codes are of block type (as with Reed-Solomon codes <xref target="RFC5510"/>) or sliding window type (as with RLC codes <xref target="RFC8681"/>).
</t>

    </section>

    <section anchor="definitionsAndAbbreviations" title="Definitions and Abbreviations">
    <!-- ====================== -->

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in <xref target="RFC2119"/>.
</t>

<t>
Terms and definitions that apply to coding are available in <xref target="nc-taxonomy"/>.
More specifically, this document uses the following definitions:
<list style="hanging">
    <t hangText="Packet versus Symbol:">	a Packet is the unit of data that is exchanged over the network while a Symbol is
        the unit of data that is manipulated during the encoding and decoding operations</t>

    <t hangText="Source Symbol:">		a unit of data originating from the source that is used as input to encoding operations</t>

    <t hangText="Repair Symbol:">		a unit of data that is the result of a coding operation</t>

</list></t>

<t>This document uses the following abbreviations: <list style="hanging">
    <t hangText="E:">		size of an encoding symbol (i.e., source or repair symbol), assumed fixed (in bytes)</t>
</list></t>

    </section>


<!-- =========================================================================================== -->


    <section title="General Design Considerations">
    <!-- ====================== -->

<t>
This section lists a few general considerations that govern the framework for FEC coding support in QUIC.
</t>

        <section title="FEC Code versus FEC Scheme, Block Codes versus Sliding Window Codes">
        <!-- ====================== -->

<t>
A FEC code specifies the details of encoding and decoding operations.
In addition to that, a FEC Scheme defines the additional protocol aspects required to use a particular FEC code <xref target="nc-taxonomy"/>.
In particular the FEC Scheme defines signaling (e.g., information contained in Source and Repair Packet header or trailers) needed to synchronize encoders and decoders.
<!-- Adding FEC protection to QUIC requires a FEC Scheme specification to be available that not only defines how to perform encoding and decoding (i.e., the code specification, that can be re-used from another specification of this FEC code) but also all the surrounded aspects that enable its use along with QUIC. -->
</t>

<t>
Block coding (e.g., Reed-Solomon <xref target="RFC5510"/>) and sliding window coding (e.g., RLC <xref target="RFC8681"/>) are two broad classes of FEC codes <xref target="nc-taxonomy"/>.
In the first case, the input flow must be first segmented into a sequence of blocks, FEC encoding and decoding being performed independently on a per-block basis.
In the second case rely, a sliding encoding window continuously slides over the input flow.
It is envisioned that the two classes of codes could be used to bring FEC protection to QUIC, usually with an advantage for sliding window codes when it comes to low latency communications.
</t>

        </section>

        <section title="FEC Scheme Negotiation">
        <!-- ====================== -->

<t>
There are multiple FEC Scheme candidates.
Therefore a negotiation step is needed to select one or more codes to be used over a QUIC session.
This will be implemented using the one step negotiation of the new QUIC negotiation mechanism <xref target="QUIC-transport"/>, during the QUIC handshake.
</t>

<t>
<list hangIndent="4" style="hanging">
<t hangText="Editor's notes:">
    <list style="symbols">
        <t> It is likely that FEC Scheme negotiation requires the use of a new dedicated Extension Frame Type. To Be Clarified and text updated.</t>

        <t> It is not clear whether negotiation is meant to select a **single** FEC Scheme or **multiple** FEC Schemes.
        In the second case (multiple FEC) it is required to have a complementary mechanism to indicate which FEC Scheme is used in a given REPAIR frame (which could be done through as many REPAIR frame type values as potential FEC Scheme negotiated). Is it what we want to achieve? Not sure.</t>
    </list></t>
</list> </t>

        </section>

        <section title="FEC Protection Within an Encrypted Channel">
        <!-- ====================== -->

<t>
FEC encoding is applied before any QUIC encryption and authentication processing.
Source symbols, that constitute the data units used by the FEC codec, contain cleartext data (application and/or QUIC data).
</t>

<!--
<t>
Coding should be applied to all QUIC packets except the 0RTT payloads. 
0RTT payloads are sent prior to negotiation, and the QUIC negotiation mechanism does not allow sending extension frames prior to handshake completion.
</t>
-->

        </section>

        <section title="About Middleboxes">
        <!-- ====================== -->

<t>
The coding approach described in this document does not allow on path elements (middleboxes) to take part in FEC protection.
The traffic being encrypted end-to-end, the middleboxes are not in position to perform FEC decoding, nor to add any redundant traffic.
</t>

        </section>

    </section>


<!-- =========================================================================================== -->


    <section anchor="sec:fec-protection-principles" title="FEC Protection Principles">
    <!-- ====================== -->

<t>
The present section explains how FEC encoding can be applied to QUIC.
It defines the general ideas for mapping QUIC packet frames to source symbols, as well as the associated signaling.
This section does not define the FEC Scheme specific details that need to be specified in a companion document.
</t>

        <section anchor="sec:cross-pkt-frames-fec" title="Cross Packet Frames FEC Encoding">
        <!-- ====================== -->

<t>
A QUIC packet payload consists in a set of QUIC frames.
These frames either carry application data (e.g., in a STREAM or DATAGRAM frame) or control information (e.g., a MAX_DATA frame).
Each packet is either entirely received or lost, and is uniquely identified by a monotonically increasing Packet Number.
</t>

<t>
Through the use of FEC encoding, application data can be protected proactively against packet losses, without requiring to go through packet retransmission.
In addition to application data, QUIC transfers might benefit from protecting control frames having a potential impact on the transmission throughput, such as MAX_DATA or MAX_STREAM_DATA frames.
Therefore this document introduces an FEC protection across all -- or a subset of -- the frames of a given QUIC packet.
This design choice impacts the QUIC packet to source symbols mapping, as well as signaling aspects, both of them being discussed hereafter.
</t>

        </section>


        <section title="Source Symbol Definition">
        <!-- ====================== -->

<t>
The cross packet frames FEC encoding approach considers the sequence of frames (or a sub-sequence of them) transmitted within a given QUIC packet, seen as the QUIC packet payload.
From this payload, it defines a mapping to source symbols (see <xref target="sec:pkt-payload-to-chunk"/> and <xref target="sec:chunk-to-src-symb"/>).
Source symbols are then used for encoding purposes, producing one or more repair symbols, the details of which depend on the FEC Scheme considered.
However source symbols are never sent per se on the network.
Instead the original QUIC packet, plus a dedicated signaling header, are sent and therefore implicitely carry those source symbols.
The QUIC packets, containing one or more repair symbols, are sent on the network.
</t>

<t>
The only modification to the original QUIC packet is the addition of a dedicated FEC_SRC_FPI frame type, meant to carry source symbol signaling (known as Source FEC Payload Information, or FPI).
On the opposite, frames that carry one or more repair symbols use a dedicated REPAIR frame type.
In both cases, in order to facilitate experiments and enable backward compatibility, the FEC_SRC_FPI and REPAIR frame types are chosen within the type range dedicated to "Extension Frames".
Thereby, a legacy receiver will automatically ignore these unknown frame types.
As QUIC packets can be of different lengths, a special care must be taken to ensure having a fixed Source Symbol size to ease FEC Scheme implementations.
</t>


                <section anchor="sec:pkt-payload-to-chunk" title="Packet Payload to Packet Chunk Mapping">
                <!-- ====================== -->

<t>
This section defines a mechanism to segment a QUIC packet payload, composed of several frames, into fixed-size payload chunks, of size E-1 bytes or E-1-4 bytes for the first chunk when the QUIC Packet Number needs to be added ((<xref target="sec:chunk-to-src-symb"/>).
Depending on the relative value of E-1 (or E-1-4) and the QUIC packet payload size, a packet can potentially contain more than one chunks.
This is a first step into producing source symbols.
<xref target="fig:frame-2-chunk-mapping"/> illustrates this process.
</t>


                    <figure anchor="fig:frame-2-chunk-mapping" title="Example of QUIC packet to chunk mapping, when the E-1 value is relatively small, with prepended zero padding when needed (here packets 1 and 2), and assuming the first chunk contains the QUIC Packet Number in 4 bytes compressed version.">
                    <artwork><![CDATA[
                  |<E-1-4>|< E-1 >|< E-1 >|< E-1 >|
                  |       |       |       |       |
           +------|-------|-------|-------|-------|
QUIC pkt 0 |Header|      Packet Payload           | chunks 0, 1, 2, 3
           +------|-----+-|-------|-------|-------+
QUIC pkt 1 |Header| 0   | Packet Payload  |         chunks 4, 5, 6
           +------|---+-+-|-------|-------|
QUIC pkt 2 |Header| 0 |  Packet Payload   |         chunks 7, 8, 9
           +------|---+---|-------|-------|
                    ]]></artwork>
                    </figure>


                </section>

                <section anchor="sec:chunk-to-src-symb" title="Packet Chunk to Source Symbol Mapping">
                <!-- ====================== -->

<t>
The second step consists in producing the source symbols.
A source symbols is the concatenation of a single byte of metadata, potentially followed by the Packet Number of the associated source, plus a packet chunk.
<xref target="fig:ss-format-with-pkt-number"/> illustrates the situation where a compressed QUIC packet number is added (in general for the first chunk of a QUIC packet).
<xref target="fig:ss-format-wo-pkt-number"/> illustrates the situation where there is no QUIC packet number (in general for the following chunk(s) of a QUIC packet).
When the QUIC packet number is present, this identifier can be recovered by a receiver after successful FEC decoding. 
It means that a RECOVERED frame can be generated to the sender to indicated that this packet (identified by the QUIC packet number) has been recovered.
Each source symbol is of fixed-size E bytes.
These source symbols are only used during encoding and decoding and are not sent as-is on the network.
</t>

                    <figure anchor="fig:ss-format-with-pkt-number" title="Source symbol format with Packet Number information (e.g., first packet chunk).">
                        <artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+
|  meta data    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Packet Number (4 bytes)                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Packet chunk (E-1-4 bytes)               ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                    ]]></artwork>
                    </figure>

                    <figure anchor="fig:ss-format-wo-pkt-number" title="Source symbol format without Packet Number information (e.g., packet chunks except the first one).">
                        <artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+
|  meta data    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Packet chunk (E-1 bytes)               ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                    ]]></artwork>
                    </figure>

                    <figure anchor="fig:metadata-format" title="Source symbol metadata format.">
                        <artwork><![CDATA[
 7 6 5 4 3 2 1 0
+-+-+-+-+-+-+-+-+
|Resvd (0)|N|S|E|
+-+-+-+-+-+-+-+-+
                    ]]></artwork>
                    </figure>

<t>
<xref target="fig:metadata-format"/> shows the format of the 1 byte metadata.
The fields are the following:
<list hangIndent="4" style="hanging">
	<t hangText="Reserved field (5 bits):"> for this specification, this field MUST be equal to zero.</t>

	<t hangText="Packet Number (N) field (1 bit):"> this field indicates that the following 4 bytes contain the Packet Number (short 32-bit representation) of the associated QUIC packet
		(<xref target="QUIC-transport"/> section 17.1., Packet Number Encoding and Decoding).</t>

	<t hangText="Start (S) bit (1 bit):"> this field, when set to 1, indicates that this source symbol contains the first chunk of the packet payload.</t>

	<t hangText="End bit (E) (1 bit):"> this field, when set to 1, indicates that this source symbol contains the last chunk of the packet payload.</t>
</list>
Note that with a QUIC packet containing a single chunk, the associated metadata will contain S=E=1.
On the opposite, a source symbol containing a intermediate chunk (i.e., neither the first nor the last chunk of the QUIC packet), the associated metadata will contain S=E=0.
</t>

                    <figure anchor="fig:ss-encoding" title="Example of packet chunk to source symbol mapping, when the E value is relatively small, in presence of the QUIC Packet Number for the first chunk.">
                        <artwork><![CDATA[
QUIC packet
          |<E-1-4>|< E-1 >|< E-1 >|< E-1 >|
   +------|----+--|-------|-------|-------|
   |Header| 0  |   Packet Payload         | 4 packet chunks
   +------|----+--|-------|-------|-------|
          /         |          |          \
         v          v          v           v
+-+--+----+  +-+-------+  +-+-------+  +-+-------+
|m|pn|chnk|  |m|  chunk|  |m|  chunk|  |m|  chunk| 4 source symbols
+-+--+----+  +-+-------+  +-+-------+  +-+-------+
|         |  |         |  |         |  |         |
|< --E-- >|  |< --E-- >|  |< --E-- >|  |< --E-- >|
                    ]]></artwork>
                    </figure>

<t>
<xref target="fig:ss-encoding"/> shows an example where the 4 source symbols are created from the payload of a given QUIC packet.
The first chunk may contain zero padding at the begining in order to align the protected packet payload size to a multiple of E-1, and the first source symbol may contain the QUIC Packet Number.
</t>

<t>
Each source symbol is uniquely identified allowing to determine unambiguously its position in the source symbol flow.
What information to associate to a source symbol to uniquely identify it is FEC Scheme dependant.
<xref target="sec:src_symb_signaling"/> gives insight on this topic.
</t>


                    <section title="Open questions: Content of Source Symbols Metadata? Removing certain frames from FEC protection?">
                    <!-- ====================== -->

<t>
<list hangIndent="4" style="hanging">
	<t hangText="NB:"> section to remove once fixed.</t>
</list>
</t>

<t>
During the FEC encoding phase, additional data can be added to the source symbol. These data are only added during the encoding and MUST NOT be transmitted on the network.
The encoder and decoder MUST agree on the addition of these data to the source symbol in order to avoid decoding errors.
Here are some examples of data that can be added to a source symbol during encoding and that will be decoded upon a source symbol recovery:

<list style="symbols">
	<t>
	The packet number: adding the packet number allows the decoder to know which packet has been recovered and potentially send a feedback of which
	packet has been recovered to the QUIC sender.
	</t>
	<t>
	Additional QUIC frames: the FEC encoder can for example add PADDING frames to a source symbol before proceeding to encoding. Adding PADDING frames
	to source symbols before encoding allows protecting packets of different sizes. The smaller packet payload will be added PADDING frames to reach a size
    that is a multiple of E-1.
	</t>
</list>

<list hangIndent="4" style="hanging">
	<t hangText="Note:"> Maybe the decision of adding data such as padding in the source symbols should be left to the underlying FEC Scheme. </t>
</list>
</t>

<t>
Besides adding data to source symbols before encoding, some frames can be removed from the source symbol if their protection is not crucial for the
transmission in order to reduce the size of the source symbol. For example, ACK frames can be systematically stripped out of the source symbols. Stream frames of
non-delay-sensitive streams could also be removed from the source symbol. The encoder and decoder MUST agree on which frames must be stripped out of packet payloads.
This information might for example be encoded in the Source Symbol ID by the FEC encoder.
</t>

<t>
<list hangIndent="4" style="hanging">
	<t hangText="Note:"> We might want to propose standard ways/algorithms to add/remove data before the encoding ? </t>
</list>
</t>

<t>
<list hangIndent="4" style="hanging">
	<t hangText="TODO:"> Add a mechanism to add QUIC packet identifier to the metadata. It's useful.</t>
</list>
</t>

                    </section>

                </section>

                <section title="Source Symbol Size (E) Considerations">
                <!-- ====================== -->

<t>
The source symbol size, E, MUST be strictly greater than zero bytes and strictly smaller than the minimum PMTU value allowed by QUIC.
The packet header is not part of the FEC-protected data.
When the packet payload size is not a multiple of E-1, zero-padding MUST be added at the beginning of the first chunk of the packet payload.
This is equivalent to inserting PADDING frames at the beginning of the payload.
This zero-padding, only used for FEC encoding, SHOULD NOT be sent on the wire.
</t>

<t>
The choice of an appropriate value for E may depends on the use case (in particular on the nature of application data).
A reasonably small value reduces the expected value of the added padding needed to align the payload size with a multiple of E-1, which can be a good approach when dealing with QUIC packets whose size significantly vary.
However an overly small value also increases processing complexity (FEC encoding and decoding are performed over a larger linear system since there are more source symbols), so there is an incentive to use a larger value.
An appropriate balance should be found, and this choice is considered as out of scope for this document.
Since a repair symbol will transit through a frame, the E value must take this into account to avoid having REPAIR frames that do not fit into a single QUIC packet.
</t>

                </section>

        </section>

        <section anchor="sec:src_symb_signaling" title="Source Symbol Signaling">
        <!-- ====================== -->

<t>
An explicit signaling is needed by a decoder to identify the source symbols and their position in the block (i.e., for block codes) or coding window (i.e., for sliding window codes).
While the QUIC packet number increases monotonically, it cannot be used to identify the position of a packet in the coding window as the packet number is not needed to increase by 1 for each new packet.
There is thus an ambiguity on the decoder-side between lost packets and packets that do not exist.
Similarly to FECFRAME, we propose to assign a identifier to source symbols to avoid this ambiguity. This identifier is opaque to the protocol and will be defined by the underlying FEC schemes.
This is out of the scope of this document. An example of identifier could be an integer increasing by 1 for each new source symbol
</t>

<t>
In order to announce the source symbol identifier to the FEC decoder, we propose to add a new frame, the FEC_SRC_FPI frame to packets whose payload will contain one or more source symbols from the FEC decoder point of view.
The FEC_SRC_FPI frame is part of the packet payload itself.
Any packet containing a FEC_SRC_FPI frame MUST see its payload considered as one or more source symbol(s).
</t>

<t>
The FEC_SRC_FPI frame format is FEC Scheme specific and MUST be specified in the associated document.
</t>

        </section>

        <section title="Repair Symbol Signaling">
        <!-- ====================== -->

<t>
An explicit signaling is needed by a decoder for each repair symbol received through a REPAIR frame.
The goals are manyfold: identifying the repair symbols and their position in the block (i.e., for block codes) or coding window (i.e., for sliding window codes);
carrying information on the way this repair symbol has been produced (e.g., with sliding window codes, it can indicate the encoding window composition).
</t>

<t>
One or more repair symbols can be present in a given QUIC packet.
When there are multiple symbols, they SHOULD be concatenated in the same REPAIR frame.
How to achieve this goal is FEC Scheme specific and therefore must be defined in the document describing this FEC Scheme.
</t>

        </section>

        <section title="Signaling a Symbol Recovery">
        <!-- ====================== -->

<t>
When all the source symbols of a given QUIC packet have been lost but are recovered during FEC decoding, a QUIC receiver SHOULD advertise it to the sender in order to avoid the retransmission of already available data.
However, the QUIC receiver MUST NOT acknowledge this recovered packet through a regular acknowledement, as it would interfere with the behaviour of loss-based congestion controls such as <xref target="Cubic"/>.
Therefore this document introduces a dedicated RECOVERED frame, that enables a receiver to indicate that a specific QUIC packet has been recovered through FEC decoding.
</t>

<t>
The RECOVERED frame works at the packet level.
It is therefore required to be able to identify to which packet the recovered source symbols belong to.
This is made possible by the QUIC packet identifier field added to the meta data prior to FEC encoding (<xref target="sec:chunk-to-src-symb"/>).
</t>

        </section>


        <section title="About Gaps in the Set of Source Symbols Considered During Encoding">
        <!-- ====================== -->

<t>
A given FEC Scheme MAY support or not the presence of gaps in the set of source symbols that constitute a block (for Block codes) or an encoding window (for Sliding Window codes).
A potential cause for non contiguous sets of source symbols is the acknowledgment of one of them.
When this happens, the QUIC sending endpoint may want to remove this source symbol from further FEC encodings.
This is particularly true with Sliding Window codes because of their flexibility during FEC encoding (i.e., the encoding window can change between two consecutive FEC encodings).
</t>

<t>
Supporting gaps can be motivated by the desire to reduce encoding and decoding complexity since there are fewer variables.
However this choice has major consequences in terms of signaling.
Indeed each repair symbol transmitted MUST be accompanied with enough information for the QUIC decoding endpoint to unambiguously identify the exact composition of the block or encoding window.
Without any gap, the identity of the first source symbol plus the number of symbols in the block or encoding window is sufficient.
With gaps, a more complex encoding needs to be used, perhaps similar to the encoding used for selective acknowledgments.
</t>

<t>
Whether or not gaps are supported MUST be clarified in each FEC Scheme.
</t>

        </section>

    </section>


<!-- =========================================================================================== -->

    <section title="FEC Scheme Negotiation in QUIC">
    <!-- ====================== -->

<t>
FEC Scheme negotiation has two goals:
<list style="symbols">
    <t>Selecting a FEC Scheme (or FEC Schemes) that can be used by the QUIC transmission and reception endpoints.
    This process requires an exchange between them;</t>

    <t>Communicating a certain number of parameters, the "Configuration Information", that are not expected to change over the session lifetime.
    For instance, this is the case of the symbol size parameter, E (in bytes), that needs either to be agreed between the endpoints,
    or chosen by the sender and communicated to the receiver(s);</t>
</list>
</t>

<t>
<list hangIndent="4" style="hanging">
<t hangText="Editor's notes:">
    <list style="symbols">
    <t> It is likely that FEC Scheme negotiation requires the use of a new dedicated Extension Frame Type. The details remain TBD.</t>
    <t> The Negotiation Frame Type format remains TBD.</t>
    <t> How to communicate the parameters remains TBD.</t>
    <t> The present document only provides high level principles, the details are of course the responsibility of the FEC Scheme.</t>
    <t> In case negotiation is different when protecting a single versus several streams, this section may be moved to the respective sections.</t>
    <t> How does it work in case of a multicast session?</t>
    <t> Do we negotiate here a FEC Scheme on a per-Stream basis (or group of Streams to be protected jointly)?
        Or do we negotiate a FEC Scheme on a QUIC session basis, therefore to be used for all the Streams that need FEC protection?</t>
    </list></t>
</list>
</t>

    <section title="FEC Scheme Negotiation">
        <t>
            Before defining the transport parameters, we define two structures, encoder_fec_scheme_t and decoder_fec_scheme_t,
            in <xref target="fig_fec_schemes_structures"/>.
            The config field is an opaque field allowing the decoder to define supported configuration information for the associated FEC Scheme.
            A FEC Scheme specification MUST define the set of valid configurations for the FEC Scheme.

            <figure anchor="fig_fec_schemes_structures" title="encoder_fec_scheme_t and decoder_fec_scheme_t structures.">
                <artwork><![CDATA[
struct {
    varint fec_scheme_id;
} encoder_fec_scheme_t

struct {
    varint   fec_scheme_id;
    uint16_t config_length;
    uint8_t  config[config_length];
} decoder_fec_scheme_t


]]></artwork>
            </figure>

            The following three transport parameters are used by the QUIC endpoints to negotiate the FEC Scheme used during the connection.

            <list style="symbols">
                <t> supported_encoder_fec_schemes: list of supported FEC schemes for the encoding part listed from the most
                    to the least preferred. The value of this parameter consists in a list of encoder_fec_scheme_t.
                    When announcing a FEC Scheme, the encoder MUST be able handle every FEC Scheme configuration considered valid.</t>
                <t> supported_decoder_fec_schemes: list of supported FEC schemes for the decoding part listed from the
                    most to the least preferred. The value of this parameter consists in a list of decoder_fec_scheme_t,
                    each one representing the ID of a supported FEC Scheme. </t>
                <t> receiving_symbol_size: the size in bytes of the symbols the peer is willing to receive and recover.
                    The value is a 16-bits integer. </t>
            </list>
        </t>

        <t>
            Since communications can be bidirectional, each QUIC endpoint can provide the three parameters.
            Conversely, providing a empty list indicates this endpoint does not support FEC for the associated communication path
            (e.g., an empty supported_decoder_fec_schemes list indicates this endpoint cannot perform FEC decoding).
        </t>

        <t>
            The decoding FEC Scheme of a QUIC endpoint is set to the first FEC Scheme listed in its own supported_decoder_fec_schemes
            that also appears in the peer's supported_encoder_fec_schemes.
            The encoding FEC Scheme of a QUIC endpoint is set to the first FEC Scheme listed in the peer's supported_decoder_fec_schemes
            that also appears in its own supported_encoder_fec_schemes.

            The encoder-side symbol size (E) of a QUIC endpoint is set to the value announced by the peer's receiving_symbol_size
            transport parameter. The decoder-side symbol size of a QUIC endpoint is set to the value announced in its own
            receiving_symbol_size transport parameter.
        </t>


        <figure anchor="fig_fec_schemes_negotiation" title="Example FEC Schemes negotiation during the QUIC handshake.">
            <artwork><![CDATA[
Host 1                                                         Host 2
      < - - - - - - - - - - - - - - - - - - - - - - - - - - - -
            supported_encoder_fec_schemes{RLC_GF256,REED_SOLOMON,XOR}
                      supported_decoder_fec_schemes{REED_SOLOMON,XOR}
                                           receiving_symbol_size{500}

      - - - - - - - - - - - - - - - - - - - - - - - -- - -  - >
supported_encoder_fec_schemes{RLC_GF256,REED_SOLOMON,XOR}
supported_decoder_fec_schemes{RLC_GF256,REED_SOLOMON}
receiving_symbol_size{200}

ENCODER_FEC_SCHEME = REED_SOLOMON
DECODER_FEC_SCHEME = RLC_GF256
ENCODER_SYMBOL_SIZE = 500
DECODER_SYMBOL_SIZE = 200

                                       ENCODER_FEC_SCHEME = RLC_GF256
                                    DECODER_FEC_SCHEME = REED_SOLOMON
                                            ENCODER_SYMBOL_SIZE = 200
                                            DECODER_SYMBOL_SIZE = 500
]]></artwork>
        </figure>

        <t>
            It is possible that the QUIC endpoint that receives one or more FEC Scheme proposals from the initiator cannot select any of them.
            In that case the negotiation process fails and no FEC protection is used.
        </t>

    </section>




    </section>


<!-- =========================================================================================== -->


    <section title="Security Considerations">
    <!-- ====================== -->

<t>TBD
</t>

    </section>

    <section anchor="iana" title="IANA Considerations">
    <!-- ====================== -->

<t>TBD
</t>

    </section>

    <section title="Acknowledgments">
    <!-- ====================== -->

<t>TBD
</t>

    </section>


</middle>

<!-- =========================================================================================== -->

 <back>

    <references title="Normative References">
    <!-- ====================== -->

    &RFC2119;

    <!-- https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-quic-transport.xml -->
    <reference anchor="QUIC-transport" target="https://datatracker.ietf.org/doc/draft-ietf-quic-transport/">
        <front>
            <title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
            <author initials="J." surname="Iyengar" fullname="Jana Iyengar" role="editor">
                <organization>Fastly</organization>
            </author>
            <author initials="M." surname="Thomson" fullname="Martin Thomson" role="editor">
                <organization>Mozilla</organization>
            </author>
            <date year="2019" month="January"/>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-quic-transport (Work in Progress)"/>
    </reference>

<!--	&RFC8312;-->
    <!-- https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8312.xml -->
    <reference anchor="Cubic" target="https://www.rfc-editor.org/info/rfc8312">
        <front>
            <title>CUBIC for Fast Long-Distance Networks</title>
            <author initials="I." surname="Rhee" fullname="I. Rhee">
                <organization/>
            </author>
            <author initials="L." surname="Xu" fullname="L. Xu">
                <organization/>
            </author>
            <author initials="S." surname="Ha" fullname="S. Ha">
                <organization/>
            </author>
            <author initials="A." surname="Zimmermann" fullname="A. Zimmermann">
                <organization/>
            </author>
            <author initials="L." surname="Eggert" fullname="L. Eggert">
                <organization/>
            </author>
            <author initials="R." surname="Scheffenegger" fullname="R. Scheffenegger">
                <organization/>
            </author>
            <date year="2018" month="February"/>
            <abstract>
                <t>
                    CUBIC is an extension to the current TCP standards. It differs from the current TCP standards only in the congestion control algorithm on the sender side. In particular, it uses a cubic function instead of a linear window increase function of the current TCP standards to improve scalability and stability under fast and long-distance networks. CUBIC and its predecessor algorithm have been adopted as defaults by Linux and have been used for many years. This document provides a specification of CUBIC to enable third-party implementations and to solicit community feedback through experimentation on the performance of CUBIC.
                </t>
            </abstract>
        </front>
        <seriesInfo name="RFC" value="8312"/>
        <seriesInfo name="DOI" value="10.17487/RFC8312"/>
    </reference>

    </references>

    <references title="Informative References">
    <!-- ====================== -->
    <!-- &RFC3452; -->
    &RFC5510;
    &RFC8681;

    <reference anchor="nc-taxonomy" target="https://datatracker.ietf.org/doc/draft-irtf-nwcrg-network-coding-taxonomy/">
        <front>
            <title>Taxonomy of Coding Techniques for Efficient Network Communications</title>
            <author initials="V." surname="Roca (Ed.) et al.">
            <organization>INRIA</organization>
            </author>
            <date year="2018" month="June"/>
        </front>
        <seriesInfo name="Request For Comments" value="RFC 8406"/>
    </reference>


   </references>

</back>

</rfc>
